<script type="text/javascript">
  var graphs = <%= @graph_configs.to_json.html_safe %>;

  var svg = [];
  var graphSpinner = [];
  var x_scale;
  var circle_locked = false;


  function addLines(serie, y_scale, g2, lines_added, _graphs, graphNum) {

    
    var axis = serie.axis;
    var axis_container = d3.select("div#"+_graphs[graphNum].id+"_"+axis+"_axis");    

    if (axis != null) {
      var num_lines = 10;

      //Add zero-line
      if (y_scale(0) < h) {
        g2.append("svg:line")
          .attr("class", "graph-zero-mark")
          .attr("x1", 0)
          .attr("x2", w)
          .attr("y1", y_scale(0))
          .attr("y2", y_scale(0));

        axis_container
          .append("span")
          .attr("class","y_axis_label")
          .attr("style","top:"+(y_scale(0)-10)+"px; color: rgba(0,0,0,0.5)")
          .text("0");
      }

      // Draws y-axis labels, if configured for this series      
      axis_container
        .append("span")
        .attr("class","units_axis_label")
        .text(serie.units);

      var line_opacity = 0.20;

      // Calculating line step
      var value_range = serie.y_max - serie.y_min;
      var value_step = 0;
      if (value_range >= 10) {
        value_step = (Math.floor(value_range / 10));
        value_step = Math.round(value_step / Math.pow(10,(value_step+"").length -1))*Math.pow(10,(value_step+"").length -1);
      } else {
        value_step = Math.round((value_range / 10)*100)/100;
        value_step = Math.round(value_step*Math.pow(10,(value_step+"").length - 3))/Math.pow(10,(value_step+"").length - 3);
      }

      var opacity_scale = d3.scale.linear()
        .range([0,0.1])
        .domain([150,250]);

      // Adding positive lines
      var line_value = 0;
      while (line_value < serie.y_max) {

        line_value += value_step;
        var y_pos = y_scale(line_value);
        if ((y_pos >= 0)&&(y_pos > 250)) {
          line_opacity = 0.1;
        } else if ((y_pos >= 0)&&(y_pos > 150)) {
          line_opacity = opacity_scale(y_pos);
        } else {
          line_opacity = 0;
        }

        if (y_pos <= h) {
          if (!lines_added) { // Marks are only added on the first series
            g2.append("svg:line")
              .attr("class", "graph-horz-marks")
              .attr("x1", 0)
              .attr("x2", w)
              .attr("y1", y_pos)
              .attr("y2", y_pos)
              .attr("style","stroke: rgba(0,0,0, "+line_opacity+")");
          }

          axis_container
            .append("span")
            .attr("class","y_axis_label")
            .attr("style","top:"+(Math.round(y_pos)-10)+"px; color: rgba(0,0,0, "+Math.round(line_opacity*2*100)/100+")")
            .text(function() {
              if (line_value >= 1) {
                return Math.floor(line_value);
              } else {
                return Math.round(line_value*100)/100;
              }
            });
        }
      }

      // Adding negative values
      line_value = 0;
      while (line_value > serie.y_min) {
        line_value -= value_step;
        var y_pos = y_scale(line_value);
        line_opacity = 0.1;
        if (y_pos > 0) {
          if (!lines_added) { // Marks are only added on the first series
            g2.append("svg:line")
              .attr("class", "graph-horz-marks")
              .attr("x1", 0)
              .attr("x2", w)
              .attr("y1", y_pos)
              .attr("y2", y_pos)
              .attr("style","stroke: rgba(0,0,0, "+line_opacity+")");
          }
          axis_container
            .append("span")
            .attr("class","y_axis_label")
            .attr("style","top:"+(Math.round(y_pos)-10)+"px; color: rgba(0,0,0, "+Math.round(line_opacity*2*100)/100+")")
            .text(Math.floor(line_value));
        }
      }
    }
  }

  function addLegendElement(container_id, color, element_id, text) {
    $('#'+container_id).find('.graph-legend').prepend('<li><div class="legend-item" style="background-color:'+color+'"></div><span id='+element_id+' class="legend-label">'+text+'</span></li>');
  }

  function updateOverlayLine(time) {
    var x = Math.round(parseFloat(x_scale(time)))-1;
    d3.selectAll('.year_marker')
      .text((time.getMonth()+1)+'/'+time.getFullYear());
    $('.year_marker').css('left',x-35);
    $('.overlay-line')
      .attr('transform', 'translate('+x+',0)')
      .attr('css', 'visibility: visible;');
  }

  function moveOverlayLine() {
    var mouse_x = d3.mouse(this)[0];
    var time = new Date(x_scale.invert(mouse_x));

    if (circle_locked) return;

    updateOverlayLine(time);

    if(mouse_x < -2 || mouse_x > 1038) {
      d3.selectAll('.year_marker').style('visibility', 'hidden');
    };
  }

  $(document).ready(function() {
    animateSliders();

    //Creates generic tooltip
    $('.generic_tooltip').remove();

    var tooltip = d3.select('body')
      .append('div')
      .attr('class', 'tooltip generic_tooltip tooltip-top');

    var _total_graphs = $('.graph-canvas').map(function() { return this.id; });
    var _graphs = [];
    var _domainq = cartodb_url +'?q=SELECT%20min(min)%20as%20min,%20max(max)%20as%20max%20FROM%20(';

    for (var i = 0; i < _total_graphs.length; i++) {
      _graphs[i] = $.grep(graphs, function(e){ return e.id === _total_graphs[i]})[0];
    }

    //Creates the query needed for calculating the default domain for the charts
    for (var i = 0; i < _graphs.length; i++) {
      if(i!=0){
        _domainq = _domainq + '%20UNION%20'
      }

      svg[i] = d3.select("#"+_graphs[i].id)
        .append("svg")
        .attr("class", "svg"+i)
        .attr("width", w)
        .attr("height", h+margin_top);

      _domainq = _domainq + 'SELECT%20min(date_processed)%20as%20min,%20max(date_processed)%20as%20max%20FROM%20'+_graphs[i].table
    }

    //Creates year marker on every years timeline
    d3.selectAll(".years").each(function(d) {
      year_marker = $(this).append("<div class='year_marker'>1990</div>");
    });

    d3.json(_domainq+')%20as%20aux%20', function(data) {
      var _data = [];

      _(data).each(function(elem, key){
        _data[key] = _(elem).values();
      });

      var min_date = new Date(_data.rows[0].min);
      var std_domain = [new Date(min_date.setDate( min_date.getDate() + 1 )),new Date(_data.rows[0].max)];

      // Calculates the global x_scale
      x_scale = d3.scale.linear()
        .range([margin,w-margin])
        .domain(std_domain);

      // Calculates the years for the time axis
      var year_step = 2;
      d3.selectAll("div.years").each(function(d){
        var year_init = parseInt(std_domain[0].getFullYear());
        var year_end = parseInt(std_domain[1].getFullYear());
        for (var y = year_init; y<=year_end; y += 5) {
          var newYear = new Date();
          newYear.setDate(1);
          newYear.setMonth(0);
          newYear.setFullYear(y);

          var year_x_position = Math.round(x_scale(newYear))-15;
          $(this).append("<span class='year_label' style='left:"+year_x_position+"px'>"+y+"</span>");
        }
      });

      for (var i = 0; i < _graphs.length; i++) {
        if(_graphs[i].type == 'BarGraph') {
          graphSpinner[i] = new Spinner(spinnerBarGraphOpts).spin(document.getElementById(_graphs[i].id));
          drawBarGraph(i, std_domain);
        } else {
          graphSpinner[i] = new Spinner(spinnerGraphOpts).spin(document.getElementById(_graphs[i].id));
          drawGraph(i, std_domain);
        }
      }

    })

    function drawBarGraph(graphNum, domain) {
      d3.json('/data?q=SELECT%20*%20FROM%20'+_graphs[graphNum].table+"%20", function(data) {
        // Graph settings, domain & ranges calculation, scales, etc.
        var negat = [], posit = [];
        var grouping = (_.size(_graphs[graphNum].x_groups) > 1);
        var grouping_y = (_graphs[graphNum].grouping == 'y_axis');      

        data.rows.forEach(function(d){
          var values = [];

          _.each(_graphs[graphNum].x_groups, function(serie) {
            var value = d[serie.column];
            if (value > 0) {
              posit.push(parseFloat(value));
            } else {
              negat.push(Math.abs(parseFloat(value)));
            }
          });
        });

        var margin_x = 40;
        var margin_y = 40;
        var available_h = 280-margin_y;        
        var row_h = 0;
        if (grouping_y) {
          row_h = d3.min([available_h/data.rows.length,50]);
        } else {
          row_h = d3.min([available_h/data.rows.length,25]);
        }
        var actual_h = row_h*data.rows.length;        
        var labels_start_y = margin_y+available_h/2-actual_h/2;
        var grouping_y_separation = 10;

        var max_label_width = 0;

        // Series labels
        svg[graphNum].selectAll("text.graph-series-label")
          .data(data.rows)
          .enter()
          .append("text")
          .attr("class","graph-series-label")
          .attr("id",function(d) {
            return "series_label_"+d.cartodb_id;
          })
          .text(function(d) {
            return d[_graphs[graphNum].name_column];
          })
          .attr("x", function(d,i) {
            return margin_x;
          })
          .attr("y", function(d,i) {     
            var y = labels_start_y+(i * row_h)+row_h/2;
            return y;
          })

        var positive_color = "#546DBC";
        var negative_color = "#F0542C";
        var label_w = 363;
        var available_w = 600;
        var group_w = 0;

        if (grouping_y) {
          group_w = available_w;
        } else {
          group_w = available_w/_.size(_graphs[graphNum].x_groups);
        }

        var bar_height = 2;

        var max_negat = d3.max(negat),
          max_posit = d3.max(posit),
          max = d3.max([max_negat, max_posit]);

        var max_bar = 0;      
        if (max_negat != null) {
          max_bar = group_w*parseFloat(max)/parseFloat(parseFloat(max_negat) + parseFloat(max_posit));
        } else{
          max_bar = group_w;
        }              

        var bar_width_scale = d3.scale.linear()
          .domain([0,max])
          .range([0, max_bar]);

        var zero_x = 0;

        if (max_negat != null) {
          zero_x = bar_width_scale(max_negat); // Zero position for each group equals the bar of the maximum negative number
        }

        var group_label_ = [];

        for (var j = 0; j < _.size(_graphs[graphNum].x_groups); j++) {
          group_label_[j] = [];
          group_label_[j]["column"] = _graphs[graphNum].x_groups[j]['column'],
          group_label_[j]["label"] = _graphs[graphNum].x_groups[j]['label']
        }

        // Drawing group-x labels if there are more than one
        if (grouping && !grouping_y) {
          svg[graphNum].selectAll("text.graph-groups-label")
            .data(group_label_)
            .enter()
            .append("text")
            .attr("class","graph-groups-label")
            .text(function(d){
              return d['label'];
            })
            .attr("x", function(d,i) {
              var labelWidth = this.getComputedTextLength();
              if (labelWidth ==0) labelWidth = 70;
              return label_w + group_w*i + zero_x - labelWidth/2;
            })
            .attr("y", function(d,i) {
              return labels_start_y-30;
            });
        }

        // Drawing each x-group
        for (var j = 0; j < _.size(_graphs[graphNum].x_groups); j++) {

          // Drawing an axis for each group_x
          if ((!grouping_y)||(j == 0)) {
            var lineGraph = svg[graphNum].append("svg:line")
              .attr("x1", label_w+group_w*j+zero_x)
              .attr("y1", labels_start_y)
              .attr("x2", label_w+group_w*j+zero_x)
              .attr("y2", labels_start_y+actual_h-4)
              .style("stroke", "#ddd")
              .style("shape-rendering", "crispEdges");
          }

          var group_label_ = _graphs[graphNum].x_groups[j].label;
          var group_name_ = _graphs[graphNum].x_groups[j].column;
          var group_strokeColor_ = _graphs[graphNum].x_groups[j].strokeColor;
          var units_ = _graphs[graphNum].units;

          if (grouping && grouping_y) {
            addLegendElement(_graphs[graphNum].id, group_strokeColor_, group_name_, group_label_);
          }

          (function(group_name, units, group_strokeColor) { // We need a reference to group_name & units in runtime, for tooltips
            var group_pos_x = group_w*j;
            if (grouping_y) {
              group_pos_x = 0;
            }

            svg[graphNum].selectAll("rect."+group_name)
              .data(data.rows)
              .enter()
              .append("rect")
              .attr("class",group_name)
              .attr("x", function(d,i) {
                if (d[group_name] > 0) {
                  return label_w + group_pos_x + zero_x;
                } else {
                  return label_w + group_pos_x + zero_x - bar_width_scale(Math.abs(d[group_name]));
                }
              })
              .attr("y", function(d,i) {
                var offset_y = i*row_h+grouping_y_separation/2;
                if (grouping_y) {
                  offset_y += j*grouping_y_separation-10;
                }
                return labels_start_y + offset_y +row_h/2 - bar_height/2 - 7;
              })
              .attr("height", function(d,i) {
                return bar_height;
              })
              .attr("style",function (d) {
                if (grouping_y) {
                  return "fill: "+group_strokeColor;
                } else {
                  if (d[group_name] > 0) {
                    return "fill: "+positive_color;
                  } else {
                    return "fill: "+negative_color;
                  }                  
                }

              })
              .attr("name", function(d){
                return Math.round(d[group_name]*1000)/1000;
              })
              .attr("width", function(d,i) {
                if (d[group_name] === null) {
                  return 0; 
                }
                var bar_width = bar_width_scale(Math.abs(d[group_name]));
                if (bar_width <= 2) bar_width = 2;
                return bar_width;
              });

            svg[graphNum].selectAll("circle."+group_name)
              .data(data.rows)
              .enter()
              .append("circle")
              .attr("class", group_name+' linedot linedot'+i)
              .attr("style",function(d) {
                if (grouping_y) {
                  return "stroke: "+group_strokeColor+"; fill: #fff";
                } else {
                  if (d[group_name] > 0) {
                    return "stroke: "+positive_color+"; fill: #fff";
                  } else {
                    return "stroke: "+negative_color+"; fill: #fff";
                  }
                }
              })
              .attr("cy", function(d,i){
                var offset_y = i*row_h+grouping_y_separation/2;
                if (grouping_y) {
                  offset_y += j*grouping_y_separation-10;
                }              
                return labels_start_y + offset_y +row_h/2 - bar_height/2 - 6}
              )
              .attr("r", function(d) {
                if (d[group_name] != null) {
                  return LINE_DOT_R; 
                }
                else {
                  return 0;
                }
              })
              .attr("name", function(d){return (Math.round(d[group_name]*1000)/1000) + " " + units}) //Uses this for tooltip
              .on("mouseover", function(d) {
                var tooltipClassname = "";
                var x_tooltip = 0;

                if (d[group_name] > 0) {
                  tooltipClassname = "tooltip generic_tooltip tooltip-left";
                  x_tooltip = $(this).offset().left + 24;
                } else {                
                  tooltipClassname =  "tooltip generic_tooltip tooltip-right";
                  x_tooltip = $(this).offset().left - $(".generic_tooltip").width() - 30;
                }

                d3.select(this)
                  .transition()
                  .duration(100)
                  .attr("r",LINE_DOT_R+1);

                tooltip.style("visibility", "visible")
                  .text($(this).attr('name'))
                  .attr("class",tooltipClassname)
                  .style("top", ($(this).offset().top-11)+"px")
                  .style("left",x_tooltip+"px");

                svg[graphNum].selectAll("#series_label_"+d.cartodb_id)
                  .transition()
                  .duration(200)
                  .style("fill","#111")
              })
              .on("mousemove", moveOverlayLine)
              .on("mouseout", function(d){
                tooltip.style("visibility", "hidden");

                d3.select(this)
                  .transition()
                  .duration(100)
                  .attr("r",LINE_DOT_R);
                svg[graphNum].selectAll("#series_label_"+d.cartodb_id)
                  .transition()
                  .duration(200)
                  .style("fill","#666");
              })
              .attr("cx", function(d){
                var x = label_w + group_pos_x + zero_x;
                if (d[group_name] > 0) {
                  x += bar_width_scale(Math.abs(d[group_name]));
                } else {
                  x -= bar_width_scale(Math.abs(d[group_name]))
                }
                return x;
              });
          })(group_name_, units_, group_strokeColor_);
        }

        graphSpinner[graphNum].stop();
      });
    }

    //Draws a lineGraph
    //graphNum:graphNum of the table on the json,
    //std_domain: specific domain - keep undefined for showing the chart's own domain
    function drawGraph(graphNum, domain) {

      d3.json('/data?q=SELECT%20*%20FROM%20'+_graphs[graphNum].table+"%20order%20by%20"+_graphs[graphNum].x_axis+"%20", function(data) {
        var _data = data;

        if(domain === undefined) {
          _data['min_domain'] = d3.min(_data.rows, function(data){return data.date_processed;})
          _data['max_domain'] = d3.max(_data.rows, function(data){return data.date_processed;})
          _domain = [new Date(_data.min_domain),new Date(_data.max_domain)];
        } else {
          _domain = domain;
        }

        var x_col = _graphs[graphNum].x_axis;
        var stacked_area_accumulated = new Array();
        var min_val = 0;
        var overlay_num = 0;

        var marks_added = false;
        var g2 = svg[graphNum].append("svg:g").attr("id", "graph_marks");                

        _.each(_graphs[graphNum].series, function(serie) {

          // append one group per series
          var g = svg[graphNum].append("svg:g");
          var strokeColor_ = serie.strokeColor;
          var fillColor = serie.fillColor;
          var y_col_ = serie.column;
          var y_col_name = serie.name;

          var y_scale = d3.scale.linear()
            .range([h, margin_top])
            .domain([serie.y_min,serie.y_max]);



          addLines(serie, y_scale, g2, marks_added, _graphs, graphNum);
          marks_added = true;

          // remove null values and find min_val if negative value
          var data_col = _data.rows.filter(function(d) {
            if(d[y_col_] < min_val) {
              min_val = d[y_col_];
            }
            return (d[y_col_] != null) && (d[y_col_] != 0)
          });

          if (overlay_num === 0) {
            svg[graphNum].append("rect")
              .attr("class", "overlay-line")
              .attr("height", h)
              .attr("width", 2)
              .attr("cy", 0);
          }

          overlay_num++;

          var extended_data_col = new Array();
          extended_data_col = jQuery.extend(true,[],data_col);

          if (new Date(extended_data_col[0]['date_processed']).getFullYear() < (domain[0].getFullYear() +2)) {
            var fake_left = jQuery.extend(true,{},extended_data_col[0]);
            fake_left[x_col] = (parseInt(fake_left[x_col])-2)+"";
            extended_data_col.unshift(fake_left);
          }

          if (new Date(extended_data_col[extended_data_col.length -1]['date_processed']).getFullYear() > (domain[1].getFullYear() - 1)) {
            var fake_right = jQuery.extend(true,{},extended_data_col[extended_data_col.length - 1]);
            fake_right[x_col] = (parseInt(fake_right[x_col])+4)+"";
            extended_data_col.push(fake_right);
          }

          if (serie.class == "line") {

            var baseline = d3.svg.line()
              .x(function(d){return x_scale(new Date(d[x_col]))})
              .y(h)
              .interpolate(INTERPOLATE_METHOD);

            var line = d3.svg.line()
              .x(function(d){return x_scale(new Date(d[x_col]))})
              .y(function(d){return y_scale(d[y_col_])})
              .interpolate(INTERPOLATE_METHOD);

            g.append("svg:path")
              .attr("class", 'lineStyle')
              .attr("id", 'line'+i)
              .attr("style",'stroke:'+strokeColor_)
              .attr("d", line(extended_data_col));

            var units_ = serie.units;
            var simplify_ = serie.simplify;

            (function(strokeColor, units, y_col, simplify){  // We need a reference to strokeColor in runtime, for hover
            g.selectAll(".linedot")
              .data(data_col)
              .enter()
              .append("circle")
              .attr("class", 'linedot linedot'+i)
              //This shows only the first point during each year
              .attr("style",function(d){
                var _fill;
                if ((simplify == null)||(simplify)) {
                  _fill = (new Date(d.date_processed).getMonth() + 1 == 1) ? 'fill:'+strokeColor : 'display: none';
                } else {
                  _fill = 'fill:'+strokeColor;
                }
                return _fill;
                })
              .attr("r", LINE_DOT_R)
              .attr("name", function(d){return (Math.round(d[y_col]*1000)/1000)+ " "  + units}) //Uses this for tooltip
              .on("mouseover", function(d) {
                circle_locked = true;
                updateOverlayLine(new Date(d[x_col]));
                d3.selectAll(".overlay-line").style("visibility", "visible");
                d3.selectAll(".year_marker").style("visibility", "visible");

                tooltip.style("visibility", "visible")
                  .html($(this).attr('name'))
                  .style("top", $(this).offset().top+30+"px")
                  .style("left", $(this).offset().left-$(".generic_tooltip").width()/2-2+"px")
                  .attr("class","tooltip generic_tooltip tooltip-top");
                d3.select(this).attr("style","fill: #fff; stroke: #000")
                  .transition()
                  .duration(100)
                  .attr("r",LINE_DOT_R+1);

                // Highlighting the legend
                d3.selectAll("#"+y_col)
                  .transition()
                  .duration(200)
                  .style("color","#111");
              })
              .on("mousemove", moveOverlayLine)
              .on("mouseout", function(d){
                circle_locked = false;
                d3.selectAll(".overlay-line").style("visibility", "hidden");
                d3.selectAll(".year_marker").style("visibility", "hidden");
                tooltip.style("visibility", "hidden");
                d3.select(this).attr("style","fill: "+strokeColor+"; stroke: #fff")
                  .transition()
                  .duration(100)
                  .attr("r",LINE_DOT_R);

                d3.selectAll("#"+y_col)
                  .transition()
                  .duration(200)
                  .style("color","#aaa");
              })
              .attr("cx", function(d){return x_scale(new Date(d[x_col]))})
              .attr("cy", function(d){return y_scale(d[y_col])});
            })(strokeColor_, units_, y_col_, simplify_);

          } else if (serie.class == "area") {
            var units_ = serie.units;

            y_scale = d3.scale.linear()
              .range([h, margin_top])
              .domain([serie.y_min,serie.y_max]);

            function getAccumulatedValue(d) {
              var date = (new Date(d[x_col])).getFullYear();
              var accumulated_value = stacked_area_accumulated[date];
              if (accumulated_value == null) accumulated_value = 0;
              var current_value = d[y_col_];
              return y_scale(parseFloat(current_value)+parseFloat(accumulated_value));
            }

            var area = d3.svg.area()
              .x(function(d) {return x_scale(new Date(d[x_col]))})
              .y0(function(d) {
                var date = new Date(d[x_col]);
                var yearStr = date.getFullYear();
                var accumulated_value = stacked_area_accumulated[yearStr];
                if (accumulated_value == null) accumulated_value = 0;
                return y_scale(parseFloat(accumulated_value));
              })
              .y1(function(d) {
                return getAccumulatedValue(d);
              })
              .interpolate(INTERPOLATE_METHOD);

            g.append("svg:path")
              .attr("d", area(extended_data_col))
              .attr("style",'stroke:'+strokeColor_)
              .attr("style",'fill:'+fillColor)
              .on("mouseover", function(d) {
                d3.selectAll(".overlay-line").style("visibility", "visible");
                d3.selectAll(".year_marker").style("visibility", "visible");
              })
              .on("mousemove", moveOverlayLine)
              .on("mouseout", function(){
                d3.selectAll(".overlay-line").style("visibility", "hidden");
                d3.selectAll(".year_marker").style("visibility", "hidden");
              });

            var line = d3.svg.line()
              .x(function(d){return x_scale(new Date(d[x_col]))})
              .y(function(d){
                return getAccumulatedValue(d);
              })
              .interpolate(INTERPOLATE_METHOD);

            g.append("svg:path")
              .attr("d", line(extended_data_col))
              .attr("class", 'lineStyle')
              .attr("style",'stroke:'+strokeColor_);

            var g_circles = svg[graphNum].append("svg:g");

            g_circles.attr("class","dataCircles");

            (function(strokeColor, units, y_col){  // We need a reference to strokeColor in runtime, for hover
              g_circles.selectAll("circle")
                .data(data_col)
                .enter()
                .append("circle")
                .attr("class", 'linedot linedot'+i)
                .attr("style",function(d){ var _fill = (new Date(d.date_processed).getMonth() + 1 == 1) ? 'fill:'+strokeColor : 'display: none'; return _fill;})
                .attr("cx", function(d){return x_scale(new Date(d[x_col]))})
                .attr("cy", function(d){
                  return getAccumulatedValue(d);
                })
                .attr("r", LINE_DOT_R)
                .attr("name", function(d){
                  return (Math.floor(d[y_col] * 100) / 100).toFixed(3)+ " " + units;
                }) //Uses this for tooltip
                .on("mouseover", function(d) {
                  circle_locked = true;
                  updateOverlayLine(new Date(d[x_col]));

                  d3.selectAll(".overlay-line").style("visibility", "visible");
                  d3.selectAll(".year_marker").style("visibility", "visible");
          
                  tooltip.html($(this).attr('name'))
                    .style("visibility", "visible")
                    .style("top", $(this).offset().top+30+"px")
                    .style("left", $(this).offset().left-$(".generic_tooltip").width()/2-2+"px")
                    .attr("class","tooltip generic_tooltip tooltip-top");

                  d3.select(this).attr("style","fill: #fff; stroke: #000;")
                    .transition()
                    .duration(100)
                    .attr("r",LINE_DOT_R+1);

                  // Highlighting the legend
                  d3.selectAll("#"+y_col)
                    .transition()
                    .duration(200)
                    .style("color","#111");
                })
                .on("mousemove", moveOverlayLine)
                .on("mouseout", function(){
                  circle_locked = false;

                  d3.selectAll(".overlay-line").style("visibility", "hidden");
                  d3.selectAll(".year_marker").style("visibility", "hidden");

                  tooltip.style("visibility", "hidden");

                  d3.select(this).attr("style","fill: "+strokeColor+"; stroke: #fff;")
                    .transition()
                    .duration(100)
                    .attr("r",LINE_DOT_R);

                  // Highlighting the legend
                  d3.selectAll("#"+y_col)
                    .transition()
                    .duration(200)
                    .style("color","#aaa");
                });
            })(strokeColor_, units_, y_col_);

            // Accumulating this series' values for next stacked areas
            extended_data_col.forEach(function (d) {
              var date = (new Date(d[x_col])).getFullYear();
              var accumulated_value = stacked_area_accumulated[date];
              if (accumulated_value == null) accumulated_value = 0;
              var current_value = d[y_col_];
              stacked_area_accumulated[""+date] = parseFloat(accumulated_value) + parseFloat(current_value);
            });

          } else if (serie.class == "range") {

            var area = d3.svg.area()
              .x(function(d) {return x_scale(new Date(d[x_col]))})
              .y0(function(d) {
                return y_scale(d[y_col_]);
              })
              .y1(function(d) {
                return y_scale(d[serie.column_top]);
              })
              .interpolate(INTERPOLATE_METHOD);

            g.append("svg:path")
              .attr("d", area(extended_data_col))
              .attr("style",'stroke:'+strokeColor_)
              .attr("style",'fill:'+fillColor);

            var g_circles = svg[graphNum].append("svg:g");
            g_circles.attr("class","dataCircles");

            (function(strokeColor, units, y_col){  // We need a reference to strokeColor in runtime, for hover
              g_circles.selectAll("circle")
                .data(data_col)
                .enter()
                .append("circle")
                .attr("class", 'linedot linedot'+i)
                .attr("style",function(d){ var _fill = (new Date(d.date_processed).getMonth() + 1 == 1) ? 'fill:'+strokeColor : 'display: none'; return _fill;})
                .attr("cx", function(d){return x_scale(new Date(d[x_col]))})
                .attr("cy", function(d){
                  return y_scale(d[y_col_]) - ((y_scale(d[y_col_]) - y_scale(d[serie.column_top]))/2);
                })
                .attr("r", LINE_DOT_R)
                .attr("name", function(d){return d[y_col]+ "-" + d[serie.column_top]+" "+serie.units}) //Uses this for tooltip
                .on("mouseover", function(d) {
                  circle_locked = true;
                  updateOverlayLine(new Date(d[x_col]));

                  d3.selectAll(".overlay-line").style("visibility", "visible");
                  d3.selectAll(".year_marker").style("visibility", "visible");
          
                  tooltip.html($(this).attr('name'))
                    .style("visibility", "visible")
                    .style("top", $(this).offset().top+30+"px")
                    .style("left", $(this).offset().left-$(".generic_tooltip").width()/2-2+"px")
                    .attr("class","tooltip generic_tooltip tooltip-top");

                  d3.select(this).attr("style","fill: #fff; stroke: #000;")
                    .transition()
                    .duration(100)
                    .attr("r",LINE_DOT_R+1);

                  // Highlighting the legend
                  d3.selectAll("#"+y_col)
                    .transition()
                    .duration(200)
                    .style("color","#111");
                })
                .on("mousemove", moveOverlayLine)
                .on("mouseout", function(){
                  circle_locked = false;

                  d3.selectAll(".overlay-line").style("visibility", "hidden");
                  d3.selectAll(".year_marker").style("visibility", "hidden");

                  tooltip.style("visibility", "hidden");

                  d3.select(this).attr("style","fill: "+strokeColor+"; stroke: #fff;")
                    .transition()
                    .duration(100)
                    .attr("r",LINE_DOT_R);

                  // Highlighting the legend
                  d3.selectAll("#"+y_col)
                    .transition()
                    .duration(200)
                    .style("color","#aaa");
                });
            })(strokeColor_, units_, y_col_);            


          } else if (serie.class == "bars") {

            var bar_width = 4;

            g.selectAll("rect.bars")
                .data(data_col)
                .enter()
                .append("rect")
                .attr("rx", 2)
                .attr("ry", 2)
                .attr("class", 'bars linedot linedot'+i)
                .attr("style",'fill:'+strokeColor_)
                .attr("x", function(d){
                  return x_scale(new Date(d[x_col]))-2;
                })
                .attr("y", function(d){
                  return y_scale(d[y_col_]);
                })
                .attr("width", bar_width)
                .attr("height", function(d) {                
                  return h - y_scale(d[y_col_]);
                })
                .attr("name", function(d){return d[y_col_]+" "+serie.units});

            (function(strokeColor, units, y_col){  // We need a reference to strokeColor in runtime, for hover
              g.selectAll("circle")
                .data(data_col)
                .enter()
                .append("circle")
                .attr("class", 'linedot linedot'+i)
                .attr("style",function(d){ var _fill = (new Date(d.date_processed).getMonth() + 1 == 1) ? 'fill:#fff; stroke:'+strokeColor : 'display: none'; return _fill;})
                .attr("cx", function(d){return x_scale(new Date(d[x_col]))})
                .attr("cy", function(d){
                  return y_scale(d[y_col_]);
                })
                .attr("r", LINE_DOT_R)
                .attr("name", function(d){return d[y_col]+" "+serie.units}) //Uses this for tooltip
                .on("mouseover", function(d) {
                  circle_locked = true;
                  updateOverlayLine(new Date(d[x_col]));

                  d3.selectAll(".overlay-line").style("visibility", "visible");
                  d3.selectAll(".year_marker").style("visibility", "visible");
          
                  tooltip.html($(this).attr('name'))
                    .style("visibility", "visible")
                    .style("top", $(this).offset().top-40+"px")
                    .style("left", $(this).offset().left-$(".generic_tooltip").width()/2-4+"px")
                    .attr("class","tooltip generic_tooltip tooltip-bottom");

                  d3.select(this).attr("style","fill: #fff; stroke: #000;")
                    .transition()
                    .duration(100)
                    .attr("r",LINE_DOT_R+1);

                  // Highlighting the legend
                  d3.selectAll("#"+y_col)
                    .transition()
                    .duration(200)
                    .style("color","#111");
                })
                .on("mousemove", moveOverlayLine)
                .on("mouseout", function(){
                  circle_locked = false;

                  d3.selectAll(".overlay-line").style("visibility", "hidden");
                  d3.selectAll(".year_marker").style("visibility", "hidden");

                  tooltip.style("visibility", "hidden");

                  d3.select(this).attr("style","fill: #fff; stroke: "+strokeColor)
                    .transition()
                    .duration(100)
                    .attr("r",LINE_DOT_R);

                  // Highlighting the legend
                  d3.selectAll("#"+y_col)
                    .transition()
                    .duration(200)
                    .style("color","#aaa");
                });
            })(strokeColor_, units_, y_col_);
          }

          addLegendElement(_graphs[graphNum].id, strokeColor_,y_col_,y_col_name);

          graphSpinner[graphNum].stop();
        });

        //Overlay
        d3.selectAll(".graph-line")
          .on("mouseover", function() {
            d3.selectAll(".overlay-line").style("visibility", "visible");
            d3.selectAll(".year_marker").style("visibility", "visible");
          })
          .on("mousemove", moveOverlayLine)
          .on("mouseout", function() {
            d3.selectAll(".overlay-line").style("visibility", "hidden");
            d3.selectAll(".year_marker").style("visibility", "hidden");
          })

        // Border gradients
        var left_gradient_x = -5;
        var right_gradient_x = w-65;

        svg[graphNum].append("svg:image")
          .attr("x",left_gradient_x)
          .attr("y",0)
          .attr("width",70)
          .attr("height",h)
          .attr("xlink:href", "<%= asset_path 'left_gradient.png' %>");

        svg[graphNum].append("svg:image")
          .attr("x",right_gradient_x)
          .attr("y",0)
          .attr("width",70)
          .attr("height",h)
          .attr("xlink:href", "<%= asset_path 'right_gradient.png' %>");

        // Bringing all circles over lines + areas + overlay lines
        svg[graphNum].selectAll("circle").each(function() {
          svg[graphNum].node().appendChild(this);
        });
      });
    }

    // Year marker
    d3.selectAll(".years")
      .on("mouseover", function() {
        d3.selectAll(".overlay-line").style("visibility", "visible");
        d3.selectAll(".year_marker").style("visibility", "visible");
      })
      .on("mousemove", moveOverlayLine)
      .on("mouseout", function(){
        d3.selectAll(".overlay-line").style("visibility", "hidden");
        d3.selectAll(".year_marker").style("visibility", "hidden");
      });
  });
</script>